/**
 * Git integration for incremental index updates
 */

import { execSync, exec } from 'child_process';
import fs from 'fs';
import path from 'path';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * Get files changed since a specific commit
 */
export async function getChangedFilesSinceIndex(
  projectRoot: string,
  lastIndexedCommit: string | null
): Promise<string[]> {
  if (!lastIndexedCommit) {
    // No previous index, return empty (will trigger full rebuild)
    return [];
  }
  
  try {
    const currentHead = await getCurrentCommit(projectRoot);
    
    if (currentHead === lastIndexedCommit) {
      // No changes
      return [];
    }
    
    // Get changed files between commits
    const { stdout } = await execAsync(
      `git diff --name-only ${lastIndexedCommit}...HEAD`,
      { cwd: projectRoot }
    );
    
    const files = stdout.trim().split('\n').filter(Boolean);
    
    // Also include uncommitted changes
    const { stdout: statusOut } = await execAsync(
      'git status --porcelain',
      { cwd: projectRoot }
    );
    
    const uncommitted = statusOut
      .trim()
      .split('\n')
      .filter(Boolean)
      .map(line => line.slice(3).trim())
      .filter(f => !f.includes(' -> ')); // Exclude renames for simplicity
    
    return [...new Set([...files, ...uncommitted])];
  } catch {
    // Not a git repo or error - return empty to skip incremental
    return [];
  }
}

/**
 * Get current git HEAD commit
 */
export async function getCurrentCommit(projectRoot: string): Promise<string | null> {
  try {
    const { stdout } = await execAsync('git rev-parse HEAD', { cwd: projectRoot });
    return stdout.trim();
  } catch {
    return null;
  }
}

/**
 * Check if the repo has uncommitted changes
 */
export async function hasUncommittedChanges(projectRoot: string): Promise<boolean> {
  try {
    const { stdout } = await execAsync('git status --porcelain', { cwd: projectRoot });
    return stdout.trim().length > 0;
  } catch {
    return false;
  }
}

/**
 * Install post-commit and post-checkout hooks for auto-refresh
 */
export async function installGitHook(projectRoot: string): Promise<void> {
  const hooksDir = path.join(projectRoot, '.git', 'hooks');
  
  if (!fs.existsSync(hooksDir)) {
    // Not a git repo
    console.warn('No .git/hooks directory found, skipping hook installation');
    return;
  }
  
  const hookScript = `#!/bin/sh
# Auto-generated by vectorize
# Refresh vector index after git operations

# Check if vectorize is available
if ! command -v npx &> /dev/null; then
  exit 0
fi

# Only run if index exists
if [ -d ".vectorindex" ]; then
  # Run in background to not block git operations
  (npx vectorize refresh --quiet &) 2>/dev/null
fi
`;

  // Install post-commit hook
  const postCommitPath = path.join(hooksDir, 'post-commit');
  await writeHookFile(postCommitPath, hookScript);
  
  // Install post-checkout hook
  const postCheckoutPath = path.join(hooksDir, 'post-checkout');
  await writeHookFile(postCheckoutPath, hookScript);
  
  // Install post-merge hook
  const postMergePath = path.join(hooksDir, 'post-merge');
  await writeHookFile(postMergePath, hookScript);
}

/**
 * Uninstall git hooks
 */
export async function uninstallGitHook(projectRoot: string): Promise<void> {
  const hooksDir = path.join(projectRoot, '.git', 'hooks');
  const hookNames = ['post-commit', 'post-checkout', 'post-merge'];
  
  for (const hookName of hookNames) {
    const hookPath = path.join(hooksDir, hookName);
    
    if (fs.existsSync(hookPath)) {
      const content = fs.readFileSync(hookPath, 'utf-8');
      
      // Only remove if it's our hook
      if (content.includes('Auto-generated by vectorize')) {
        fs.unlinkSync(hookPath);
      }
    }
  }
}

/**
 * Write hook file, preserving existing hooks
 */
async function writeHookFile(hookPath: string, script: string): Promise<void> {
  if (fs.existsSync(hookPath)) {
    const existing = fs.readFileSync(hookPath, 'utf-8');
    
    // Check if our hook is already installed
    if (existing.includes('Auto-generated by vectorize')) {
      // Already installed, update it
      fs.writeFileSync(hookPath, script);
      fs.chmodSync(hookPath, 0o755);
      return;
    }
    
    // Append our hook to existing
    const combined = existing + '\n\n' + script;
    fs.writeFileSync(hookPath, combined);
    fs.chmodSync(hookPath, 0o755);
  } else {
    // Create new hook
    fs.writeFileSync(hookPath, script);
    fs.chmodSync(hookPath, 0o755);
  }
}

/**
 * Get list of files in the last commit
 */
export async function getLastCommitFiles(projectRoot: string): Promise<string[]> {
  try {
    const { stdout } = await execAsync(
      'git diff-tree --no-commit-id --name-only -r HEAD',
      { cwd: projectRoot }
    );
    return stdout.trim().split('\n').filter(Boolean);
  } catch {
    return [];
  }
}

/**
 * Check if project is a git repository
 */
export function isGitRepo(projectRoot: string): boolean {
  return fs.existsSync(path.join(projectRoot, '.git'));
}

/**
 * Get git ignore patterns to exclude from indexing
 */
export async function getGitIgnorePatterns(projectRoot: string): Promise<string[]> {
  const gitignorePath = path.join(projectRoot, '.gitignore');
  
  if (!fs.existsSync(gitignorePath)) {
    return [];
  }
  
  const content = fs.readFileSync(gitignorePath, 'utf-8');
  
  return content
    .split('\n')
    .map(line => line.trim())
    .filter(line => line && !line.startsWith('#'))
    .map(pattern => {
      // Convert gitignore patterns to glob patterns
      if (pattern.startsWith('/')) {
        return pattern.slice(1);
      }
      if (!pattern.includes('/')) {
        return `**/${pattern}`;
      }
      return pattern;
    });
}
